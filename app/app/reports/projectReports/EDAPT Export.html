<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Something</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width">
  <!--TODO Make this css injection work (replace hard-coded CSS paths below)-->
  <!-- build:css({.tmp/serve,src}) styles/vendor.css -->
  <!-- inject:bootstrap -->
  <!-- bootstrap css files will be automatically insert here -->
  <!-- endinject -->
  <!-- bower:css -->
  <!-- run `gulp inject` to automatically populate bower styles dependencies -->
  <!-- endbower -->
  <!-- endbuild -->

  <!-- build:css({.tmp/serve,src}) styles/app.css -->
  <!-- inject:css -->
  <!-- css files will be automatically insert here -->
  <!-- endinject -->
  <!-- endbuild -->
  <link rel="stylesheet" href="/app/bootstrap.css">
  <link rel="stylesheet" href="/app/index.css">
</head>
<body>

<div ng-app="myApp">

  <div ng-controller="MyAppCtrl">

    <h1>EDAPT Export</h1>
    <h2>Select Baselines</h2>
    <table class="table-bordered table-condensed table-striped">
      <tr>
        <th>Baseline Type</th>
        <th>Name</th>
      </tr>
      <tr>
        <td>EDA Baseline</td>
        <td>
          <select ng-model="eda_baseline">
            <option ng-repeat="run in results">{{run.name}}</option>
          </select>
        </td>
      </tr>
      <tr>
        <td>Proposed/Cost Baseline</td>
        <td>
          <select ng-model="proposed_baseline">
            <option ng-repeat="run in results">{{run.name}}</option>
          </select>
        </td>
      </tr>
      <tr>
        <td>Certification (LEED) Baseline</td>
        <td>
          <select ng-model="certification_baseline">
            <option ng-repeat="run in results">{{run.name}}</option>
          </select>
        </td>
      </tr>
    </table>

    <h2>Runs to Export</h2>
    <li>Only the checked rows will be exported</li>
    <li>Only unique Measures are shown; always-run and reporting Measures are not shown</li>
    <li>Single Measures are the focus of the PEA report</li>
    <li>Design Alternatives are the focus of the FEA report, but Single Measure results will be included in a separate
      table
    </li>
    </ul>
    <table class="table-bordered table-condensed table-striped">
      <tr>
        <th></th>
        <th>Export?</th>
        <th>Name</th>
        <th>Measures</th>
        <th>Type</th>
      </tr>
      <tr ng-repeat="run in results">
        <td>
          <button type="button" class="btn btn-success" ng-click="up($index)">&uarr;</button>
          <button type="button" class="btn btn-success" ng-click="down($index)">&darr;</button>
        </td>
        <td>
          <input type="checkbox" ng-model="run.export" ng-init="run.export=true">
        </td>
        <td>{{ run.name }}</td>
        <td>
          <ul>
            <li ng-repeat="measure_name in run.measure_names">{{ measure_name }}</li>
          </ul>
        </td>
        <td>
          <select ng-model="run.run_type">
            <option ng-repeat="runType in runTypes">{{runType}}</option>
          </select>
        </td>
      </tr>
    </table>
    <br/>
    <label class="medium-label">File Name</label>
    <input ng-model="results_file_name" ng-change="updateResultsFilePath()">
    <br/>
    <button type="button" class="btn btn-success" ng-click="exportEDAPTXML()">
      <translate>Export EDAPT XML</translate>
    </button>

  </div>

</div>

<script type="text/javascript">

  console.info("Loaded measure.html script");

  // Code to move an object in an array to a new index
  // Copied from http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
  Array.prototype.move = function (old_index, new_index) {
    if (new_index >= this.length) {
      var k = new_index - this.length;
      while ((k--) + 1) {
        this.push(undefined);
      }
    }
    this.splice(new_index, 0, this.splice(old_index, 1)[0]);
    return this; // for testing purposes
  };

  angular.module('myApp', [])
    .controller('MyAppCtrl', function ($scope) {
      // Bind the simulation results to a variable
      $scope.results = results;

      // Create a variable for the file save location
      $scope.results_file_name = "results";
      $scope.results_file_path = reportDir + "/" + $scope.results_file_name + ".xml";

      // Update the save location when the input changes
      $scope.updateResultsFilePath = function () {
        $scope.results_file_path = reportDir + "/" + $scope.results_file_name + ".xml";
      };

      // Create variables for the baseline types
      $scope.eda_baseline = "";
      $scope.cost_baseline = "";
      $scope.proposed_baseline = "";

      // Get the unique measure counts
      // TODO make sure to check the arguments AND
      // whether or not the measure is present in a run,
      // because you could have a situation where the same
      // measure is run for all alternatives with different
      // arguments
      var measureCounts = {};
      var numAlts = 0;
      _.forEach($scope.results, function (run) {
        $scope.numAlts += 1;
        _.forEach(run.steps, function (step) {
          if (step.measure_dir_name) {
            if (measureCounts[step.measure_dir_name]) {
              measureCounts[step.measure_dir_name] += 1;
            } else {
              measureCounts[step.measure_dir_name] = 1;
            }
          }
        });
      });

      // Set the measure_names property of each run
      _.forEach($scope.results, function (run) {
        run.measure_names = measureNames(run, measureCounts, numAlts);
        console.log(run.name + "measures" + run.measure_names);
      });

      // Set the default run_type property of each run
      // based on the number of measures it has
      $scope.singleMeasure = "Single Measure";
      $scope.designAlt = "Design Alternative";
      $scope.runTypes = ["Single Measure", "Design Alternative"];
      _.forEach($scope.results, function (run) {
        var numMeasures = run.measure_names.length;
        if (numMeasures == 1) {
          run.run_type = $scope.singleMeasure;
        } else {
          run.run_type = $scope.designAlt;
        }
        console.log(run.name + "measures" + run.measure_names);
      });

      // Move the design alternative up one position
      $scope.up = function (index) {
        console.log("index: " + index);
        if (index > 0) {
          $scope.results.move(index, index - 1);
        }
      };

      // Move the design alternative down one position
      $scope.down = function (index) {
        console.log("index: " + index);
        if (index < $scope.results.length - 1) {
          $scope.results.move(index, index + 1);
        }
      };

      // Export the EDAPT XML report using the
      // options the user has defined in the table.
      $scope.exportEDAPTXML = function () {
        console.info("Exporting EDAPT XML");
        console.log("Measure Counts:");
        console.log(measureCounts);

        // analysis
        var analysis = {};
        analysis.simulation_software = "OpenStudio";

        // alternatives
        var alts = [];
        _(results).forEach(function (run) {

          // Skip any run not selected for export
          if (!run.export) {
            console.log("Skipping " + run.name + " because it is was not selected.");
            return;
          }

          console.log("Run " + run.name);
          var alt = {};
          alts.push(alt);

          // name
          alt.name = run.name;

          // baseline types
          var baseline_types = [];
          // EDA_Baseline
          if (alt.name == $scope.eda_baseline) {
            baseline_types.push("EDA Baseline");
          }
          // Proposed Baseline
          if (alt.name == $scope.proposed_baseline) {
            baseline_types.push("Proposed Baseline");
          }
          // Certification Baseline
          if (alt.name == $scope.certification_baseline) {
            baseline_types.push("Certification Baseline");
          }
          alt.baseline_type = baseline_types;

          // description
          alt.description = run.description;

          // TODO characteristics
          var chars = {};
          chars.building = {};
          chars.building.floor_area = 999.99;
          alt.characteristics = chars;

          // find all measures that are in this alternative
          var measures = [];
          _(run.steps).forEach(function (step) {

            // skip always-run measures
            if (measureCounts[step.measure_dir_name] == numAlts) {
              console.log("Skipping " + step.measure_dir_name + " because it is an always-run Measure.");
              return;
            }

            var measure = {};
            measure.name = step.name;
            measure.id = step.measure_id;
            measure.category = "Envelope.Opaque"; // TODO step.taxonomy;
            measure.description = step.description;
            measure.initial_condition = step.result.initial_condition;
            measure.final_condition = step.result.final_condition;
            measures.push(measure);
          });
          alt.measures = measures;

          // alternative_type
          if (run.run_type == "Design Alternative") {
            alt.alternative_type = "design_alternative";
          } else if (run.run_type == "Single Measure") {
            alt.alternative_type = "single_measure";
          }

          // find the EDAPT output report
          // TODO figure out how to identify this Measure
          // no matter what the name of the Measure is,
          // because it might be Xcel or Austin or whatever.
          var reportMeasure = _.find(run.steps, {'measure_dir_name': "DencityReports"});
          var vals = reportMeasure.result.step_values;

          // define the fuel types and end uses
          const cashFlowTypes = ["Capital", "Operating", "Energy", "Water", "Total"];
          const fuelTypes = ["electricity", "gas", "other_energy", "district_cooling", "district_heating", "water"];
          const demandTypes = ["electricity_peak_demand", "electricity_annual_avg_peak_demand", "district_cooling_peak_demand"];
          const utilCostFuelTypes = ["electricity", "electricity_consumption_charge", "electricity_demand_charge", "gas", "other_energy", "district_cooling", "district_heating", "water", "total"];
          const endUses = ["heating", "cooling", "lighting_interior", "lighting_exterior", "equipment_interior", "equipment_exterior", "fans", "pumps", "heat_rejection", "humidification", "heat_recovery", "water_systems", "refrigeration", "generators"];

          // results
          alt.results = {};

          // cash_flows
          var cashFlows = [];
          _(cashFlowTypes).forEach(function (flowType) {
            var cashFlow = {};
            // type
            output = _.find(vals, {'name': "cash_flows_" + flowType.toLowerCase() + "_type"});
            if (output) {
              cashFlow.type = output.value;
            }
            // yearly values
            var values = [];
            for (var k = 1; k < 100; k++) {
              var output = _.find(vals, {'name': "cash_flows_" + flowType.toLowerCase() + "_year_" + k});
              if (output) {
                values.push(output.value);
              }
            }
            cashFlow.values = values;
            cashFlows.push(cashFlow);
          });
          alt.results.cash_flows = cashFlows;

          // annual
          alt.results.annual = {};

          // annual consumption
          var annualConsumption = {};
          _(fuelTypes).forEach(function (fuelType) {
            output = _.find(vals, {'name': "annual_consumption_" + fuelType});
            if (output) {
              annualConsumption[fuelType] = output.value;
            }
          });
          alt.results.annual.consumption = annualConsumption;

          // annual demand
          var annualDemand = {};
          _(demandTypes).forEach(function (demandType) {
            output = _.find(vals, {'name': "annual_demand_" + demandType});
            if (output) {
              annualDemand[demandType] = output.value;
            }
          });
          alt.results.annual.demand = annualDemand;

          // annual utility_cost
          var annualUtilityCost = {};
          _(utilCostFuelTypes).forEach(function (consType) {
            consType = String(consType);
            output = _.find(vals, {'name': "annual_utility_cost_" + consType});
            if (output) {
              annualUtilityCost[consType] = output.value;
            }
          });
          alt.results.annual.utility_cost = annualUtilityCost;

          // annual utility_cost end_uses
          var endUseCosts = {};
          _(endUses).forEach(function (endUse) {
            output = _.find(vals, {'name': "annual_utility_cost_end_uses_" + endUse});
            if (output) {
              endUseCosts[endUse] = output.value;
            }
          });
          alt.results.annual.utility_cost.end_uses = endUseCosts;

          // monthly
          alt.results.monthly = {};

          // monthly consumption
          var monthlyConsumption = {};
          _(endUses).forEach(function (endUse) {
            monthlyConsumption[endUse] = {};
            _(fuelTypes).forEach(function (fuelType) {
              var monthlyConsumptionFuelType = {};
              // monthly values
              var months = [];
              for (var m = 1; m < 13; m++) {
                var output = _.find(vals, {'name': "monthly_consumption_" + endUse + "_" + fuelType + "_month_" + m});
                if (output) {
                  months.push(output.value);
                }
              }
              monthlyConsumptionFuelType["month"] = months;
              // total
              output = _.find(vals, {'name': "monthly_consumption_" + endUse + "_" + fuelType + "_year"});
              if (output) {
                monthlyConsumptionFuelType["year"] = output.value;
              }
              monthlyConsumption[endUse][fuelType] = monthlyConsumptionFuelType
            });
          });
          alt.results.monthly.consumption = monthlyConsumption;

          // monthly demand
          var monthlyDemand = {};
          _(endUses).forEach(function (endUse) {
            monthlyDemand[endUse] = {};
            _(fuelTypes).forEach(function (fuelType) {
              var monthlyDemandFuelType = {};
              // monthly values
              var months = [];
              for (var m = 1; m < 13; m++) {
                output = _.find(vals, {'name': "monthly_demand_" + endUse + "_" + fuelType + "_month_" + m});
                if (output) {
                  months.push(output.value);
                }
              }
              monthlyDemandFuelType["month"] = months;
              // total
              var output = _.find(vals, {'name': "monthly_demand_" + endUse + "_" + fuelType + "_year"});
              if (output) {
                monthlyDemandFuelType["year"] = output.value;
              }
              monthlyDemand[endUse][fuelType] = monthlyDemandFuelType
            });
          });
          alt.results.monthly.demand = monthlyDemand;

        });
        analysis.alternatives = alts;

        var options = {
          arrayMap: {
            cash_flows: "cash_flow",
            values: "year",
            measures: "measure",
            alternatives: "alternative"
          }
        };

        // TODO Zip the file too
        // TODO show a success/fail message

        // Parse the JSON to XML
        var xmlText = js2xmlparser("analysis", analysis, options);

        // TODO Add the timestamp to the filename
        //var nonWord = new RegExp("\W+","g");
        //var timestamp = new Date().toLocaleString()
        //console.log(timestamp);
        //timestamp = timestamp.replace('/', '_').replace(',', '_').replace(':', '_').replace(' ', '_');
        //console.log(timestamp);
        //var save_path = $scope.results_file_path + "_" + timestamp;
        var save_path = $scope.results_file_path;

        fs.writeFile(save_path, xmlText, function (err) {
          if (err) {
            return console.log(err);
          }
          window.alert("The EDAPT XML report was saved to " + save_path);
          console.log("The EDAPT XML report was saved to " + save_path);
        });
      }

    });

  // returns a list of the user-entered measure names for
  // a given design alternative.  Does not include
  function measureNames(alternative, measureCounts, numAlts) {
    var names = [];

    _(alternative.steps).forEach(function (step) {

      // skip always-run measures
      if (measureCounts[step.measure_dir_name] == numAlts) {
        // console.log("Skipping " + step.measure_dir_name + " because it is an always-run Measure.");
        return;
      }

      if (step.name) {
        names.push(step.name);
      }

    });

    return names;

  }

  // set $scope.results element in the controller above from PAT data
  function setData(data) {
    console.log('Setting results variable to: ', data);
    var controllerElement = document.querySelector('div[ng-controller="MyAppCtrl"]');
    var $scope = angular.element(controllerElement).scope();
    $scope.$apply(function() {
      $scope.results = data;
    });
  }

</script>
