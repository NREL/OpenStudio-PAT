<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Something</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.2/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.5.8/angular.min.js"></script>
</head>
<body>

<div ng-app="myApp">

  <div ng-controller="MyAppCtrl">

    <h1>EDAPT Export</h1>
    <h2>Select Baselines</h2>
    <table class="table-bordered table-condensed table-striped">
      <tr>
        <th>Baseline Type</th>
        <th>Name</th>
      </tr>
      <tr>
        <td>EDA Baseline</td>
        <td>
          <select ng-model="eda_baseline">
            <option ng-repeat="run in results">{{run.name}}</option>
          </select>
        </td>
      </tr>
      <tr>
        <td>Proposed/Cost Baseline</td>
        <td>
          <select ng-model="proposed_baseline">
            <option ng-repeat="run in results">{{run.name}}</option>
          </select>
        </td>
      </tr>
      <tr>
        <td>Certification (LEED) Baseline</td>
        <td>
          <select ng-model="certification_baseline">
            <option ng-repeat="run in results">{{run.name}}</option>
          </select>
        </td>
      </tr>
    </table>

    <h2>Runs to Export</h2>
    <li>Only the checked rows will be exported</li>
    <li>Only unique Measures are shown; always-run and reporting Measures are not shown</li>
    <li>Single Measures are the focus of the PEA report</li>
    <li>Design Alternatives are the focus of the FEA report, but Single Measure results will be included in a separate
      table
    </li>
    </ul>
    <table class="table-bordered table-condensed table-striped">
      <tr>
        <th></th>
        <th>Export?</th>
        <th>Name</th>
        <th>Measures</th>
        <th>Type</th>
      </tr>
      <tr ng-repeat="run in results">
        <td>
          <button type="button" class="btn btn-success" ng-click="up($index)">&uarr;</button>
          <button type="button" class="btn btn-success" ng-click="down($index)">&darr;</button>
        </td>
        <td>
          <input type="checkbox" ng-model="run.export" ng-init="run.export=true">
        </td>
        <td>{{ run.name }}</td>
        <td>
          <ul>
            <li ng-repeat="measure_name in run.measure_names">{{ measure_name }}</li>
          </ul>
        </td>
        <td>
          <select ng-model="run.run_type">
            <option ng-repeat="runType in runTypes">{{runType}}</option>
          </select>
        </td>
      </tr>
    </table>
    <br/>
    <label class="medium-label">File Name</label>
    <input ng-model="results_file_name" ng-change="updateResultsFilePath()">
    <br/>
    <button type="button" class="btn btn-success" ng-click="exportEDAPTXML()">
      <translate>Export EDAPT XML</translate>
    </button>

  </div>

</div>

<script type="text/javascript">

  console.info("Loaded EDAPT Export.html script");

  // Code to move an object in an array to a new index
  // Copied from http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
  Array.prototype.move = function (old_index, new_index) {
    if (new_index >= this.length) {
      var k = new_index - this.length;
      while ((k--) + 1) {
        this.push(undefined);
      }
    }
    this.splice(new_index, 0, this.splice(old_index, 1)[0]);
    return this; // for testing purposes
  };

  angular.module('myApp', [])
    .controller('MyAppCtrl', function ($scope) {

      fs = require('fs');
      path = require('path');
      os = require('os');

      // Store a list of errors in exporting
      var exportErrs = [];

      // Update the save location when the input changes
      $scope.updateResultsFilePath = function () {
        $scope.results_file_path = $scope.reportDir + "/" + $scope.results_file_name + ".xml";
      };

      // Create variables for the baseline types
      $scope.eda_baseline = "";
      $scope.cost_baseline = "";
      $scope.proposed_baseline = "";

      // Set up some additional data properties after the results
      // are passed in.
      $scope.setupAfterResultsAvailable = function () {

        // Create a variable for the file save location
        $scope.results_file_name = "results";
        $scope.results_file_path = $scope.reportDir + "/" + $scope.results_file_name + ".xml";

        // Get the unique measure counts
        // based on unique name + argument values.
        $scope.measureCounts = {};
        $scope.numAlts = 0;
        _.forEach($scope.results, function (run) {
          $scope.numAlts += 1;
          _.forEach(run.steps, function (step) {
            var namePlusArgs = step.name + JSON.stringify(step.arguments);
            step.namePlusArgs = namePlusArgs;
            if ($scope.measureCounts[namePlusArgs]) {
              $scope.measureCounts[namePlusArgs] += 1;
            } else {
              $scope.measureCounts[namePlusArgs] = 1;
            }
          });
        });
        console.info("There are results for " + $scope.numAlts + " runs");

        // Set the measure_names property of each run
        console.info("Setting list of Measure names for each run");
        _.forEach($scope.results, function (run) {
          run.measure_names = measureNames(run, $scope.measureCounts, $scope.numAlts);
          console.log(run.name + " measures: " + run.measure_names.join(', '));
        });

        // Set the default run_type property of each run
        // based on the number of measures it has
        $scope.singleMeasure = "Single Measure";
        $scope.designAlt = "Design Alternative";
        $scope.runTypes = ["Single Measure", "Design Alternative"];
        _.forEach($scope.results, function (run) {
          var numMeasures = run.measure_names.length;
          if (numMeasures == 1) {
            run.run_type = $scope.singleMeasure;
          } else {
            run.run_type = $scope.designAlt;
          }
        });

      };

      // Move the design alternative up one position
      $scope.up = function (index) {
        console.log("index: " + index);
        if (index > 0) {
          $scope.results.move(index, index - 1);
        }
      };

      // Move the design alternative down one position
      $scope.down = function (index) {
        console.log("index: " + index);
        if (index < $scope.results.length - 1) {
          $scope.results.move(index, index + 1);
        }
      };

      // Export the EDAPT XML report using the
      // options the user has defined in the table.
      $scope.exportEDAPTXML = function () {
        console.info("Exporting EDAPT XML");
        console.log("Measure Counts:");
        console.log($scope.measureCounts);

        // analysis
        var analysis = {};
        analysis.simulation_software = "OpenStudio";

        // alternatives
        var alts = [];
        _($scope.results).forEach(function (run) {

          // Skip any run not selected for export
          if (!run.export) {
            console.log("Skipping " + run.name + " because it is was not selected.");
            return;
          }

          console.log("Run " + run.name);
          var alt = {};
          alts.push(alt);

          // name
          alt.name = run.name;

          // baseline types
          var baseline_types = [];
          // EDA_Baseline
          if (alt.name == $scope.eda_baseline) {
            baseline_types.push("EDA Baseline");
          }
          // Proposed Baseline
          if (alt.name == $scope.proposed_baseline) {
            baseline_types.push("Proposed Baseline");
          }
          // Certification Baseline
          if (alt.name == $scope.certification_baseline) {
            baseline_types.push("Certification Baseline");
          }
          alt.baseline_type = baseline_types;

          // description
          alt.description = run.description;

          // TODO characteristics
          var chars = {};
          chars.building = {};
          chars.building.floor_area = 999.99;
          alt.characteristics = chars;

          // find all measures that are in this alternative
          var measures = [];
          _(run.steps).forEach(function (step) {

            // skip measures that were set to "none"
            if (!step.arguments.__SKIP__){
              console.log("Not including " + step.name + " because it was skipped.");
              return;
            }

            // skip reporting measures
            if (step.measure_type == 'ReportingMeasure') {
              console.log("Not including " + step.name + " because it is a reporting Measure.");
              return;
            }

            // skip always-run measures
            if ($scope.measureCounts[step.namePlusArgs] == $scope.numAlts) {
              console.log("Not including " + step.name + " because it is an always-run Measure.");
              return;
            }

            // skip measures that don't have results
            if (!step.hasOwnProperty('result')) {
              console.log("Not including " + step.name + " because it is has no result.");
              return;
            }

            var measure = {};
            measure.name = step.name;
            measure.id = step.measure_id;
            measure.category = "Envelope.Opaque"; // TODO step.taxonomy;
            measure.description = step.description;
            measure.initial_condition = step.result.initial_condition;
            measure.final_condition = step.result.final_condition;
            measures.push(measure);
          });
          alt.measures = measures;

          // alternative_type
          if (run.run_type == "Design Alternative") {
            alt.alternative_type = "design_alternative";
          } else if (run.run_type == "Single Measure") {
            alt.alternative_type = "single_measure";
          }

          // Find the EDAPT output report measure
          // no matter what the name of the Measure is,
          // because it might be Xcel or Austin or whatever.
          // Find the first measure that has a step_value called
          // "cash_flows_capital_type", which should be a pretty safe bet.
          var reportMeasure = null;
          _(run.steps).forEach(function (step) {
            if (step.hasOwnProperty('result')) {
              if (_.find(step.result.step_values, {'name': "cash_flows_capital_type"})) {
                reportMeasure = step;
                console.log("EDAPT Measure is: " + reportMeasure.name);
                return;
              }
            }
          });
          // var reportMeasure = _.find(run.steps, {'name': "DencityReports"});

          // If the report measure is not found, throw a warning.
          if (!reportMeasure) {
            exportErrs.push("No EDAPT Export measure was run for " + alt.name + ", this run will not be included in the EDAPT export.");
            console.log("No EDAPT Export measure was run for " + alt.name + ", this run will not be included in the EDAPT export.");
            return;
          }

          var vals = reportMeasure.result.step_values;

          // define the fuel types and end uses
          const cashFlowTypes = ["Capital", "Operating", "Energy", "Water", "Total"];
          const fuelTypes = ["electricity", "gas", "other_energy", "district_cooling", "district_heating", "water"];
          const demandTypes = ["electricity_peak_demand", "electricity_annual_avg_peak_demand", "district_cooling_peak_demand"];
          const utilCostFuelTypes = ["electricity", "electricity_consumption_charge", "electricity_demand_charge", "gas", "other_energy", "district_cooling", "district_heating", "water", "total"];
          const endUses = ["heating", "cooling", "lighting_interior", "lighting_exterior", "equipment_interior", "equipment_exterior", "fans", "pumps", "heat_rejection", "humidification", "heat_recovery", "water_systems", "refrigeration", "generators"];

          // results
          alt.results = {};

          // cash_flows
          var cashFlows = [];
          _(cashFlowTypes).forEach(function (flowType) {
            var cashFlow = {};
            // type
            output = _.find(vals, {'name': "cash_flows_" + flowType.toLowerCase() + "_type"});
            if (output) {
              cashFlow.type = output.value;
            }
            // yearly values
            var values = [];
            for (var k = 1; k < 100; k++) {
              var output = _.find(vals, {'name': "cash_flows_" + flowType.toLowerCase() + "_year_" + k});
              if (output) {
                values.push(output.value);
              }
            }
            cashFlow.values = values;
            cashFlows.push(cashFlow);
          });
          alt.results.cash_flows = cashFlows;

          // annual
          alt.results.annual = {};

          // annual consumption
          var annualConsumption = {};
          _(fuelTypes).forEach(function (fuelType) {
            output = _.find(vals, {'name': "annual_consumption_" + fuelType});
            if (output) {
              annualConsumption[fuelType] = output.value;
            }
          });
          alt.results.annual.consumption = annualConsumption;

          // annual demand
          var annualDemand = {};
          _(demandTypes).forEach(function (demandType) {
            output = _.find(vals, {'name': "annual_demand_" + demandType});
            if (output) {
              annualDemand[demandType] = output.value;
            }
          });
          alt.results.annual.demand = annualDemand;

          // annual utility_cost
          var annualUtilityCost = {};
          _(utilCostFuelTypes).forEach(function (consType) {
            consType = String(consType);
            output = _.find(vals, {'name': "annual_utility_cost_" + consType});
            if (output) {
              annualUtilityCost[consType] = output.value;
            }
          });
          alt.results.annual.utility_cost = annualUtilityCost;

          // annual utility_cost end_uses
          var endUseCosts = {};
          _(endUses).forEach(function (endUse) {
            output = _.find(vals, {'name': "annual_utility_cost_end_uses_" + endUse});
            if (output) {
              endUseCosts[endUse] = output.value;
            }
          });
          alt.results.annual.utility_cost.end_uses = endUseCosts;

          // monthly
          alt.results.monthly = {};

          // monthly consumption
          var monthlyConsumption = {};
          _(endUses).forEach(function (endUse) {
            monthlyConsumption[endUse] = {};
            _(fuelTypes).forEach(function (fuelType) {
              var monthlyConsumptionFuelType = {};
              // monthly values
              var months = [];
              for (var m = 1; m < 13; m++) {
                var output = _.find(vals, {'name': "monthly_consumption_" + endUse + "_" + fuelType + "_month_" + m});
                if (output) {
                  months.push(output.value);
                }
              }
              monthlyConsumptionFuelType["month"] = months;
              // total
              output = _.find(vals, {'name': "monthly_consumption_" + endUse + "_" + fuelType + "_year"});
              if (output) {
                monthlyConsumptionFuelType["year"] = output.value;
              }
              monthlyConsumption[endUse][fuelType] = monthlyConsumptionFuelType
            });
          });
          alt.results.monthly.consumption = monthlyConsumption;

          // monthly demand
          var monthlyDemand = {};
          _(endUses).forEach(function (endUse) {
            monthlyDemand[endUse] = {};
            _(fuelTypes).forEach(function (fuelType) {
              var monthlyDemandFuelType = {};
              // monthly values
              var months = [];
              for (var m = 1; m < 13; m++) {
                output = _.find(vals, {'name': "monthly_demand_" + endUse + "_" + fuelType + "_month_" + m});
                if (output) {
                  months.push(output.value);
                }
              }
              monthlyDemandFuelType["month"] = months;
              // total
              var output = _.find(vals, {'name': "monthly_demand_" + endUse + "_" + fuelType + "_year"});
              if (output) {
                monthlyDemandFuelType["year"] = output.value;
              }
              monthlyDemand[endUse][fuelType] = monthlyDemandFuelType
            });
          });
          alt.results.monthly.demand = monthlyDemand;

        });
        analysis.alternatives = alts;

        var options = {
          arrayMap: {
            cash_flows: "cash_flow",
            values: "year",
            measures: "measure",
            alternatives: "alternative"
          }
        };

        // Show any errors
        if (exportErrs.length > 0) {
          window.alert("There were errors on export:\n" + exportErrs.join('\n'));
        }

        // TODO Zip the file too
        // TODO show a success/fail message

        // Parse the JSON to XML
        var xmlText = js2xmlparser("analysis", analysis, options);

        // TODO Add the timestamp to the filename
        //var nonWord = new RegExp("\W+","g");
        //var timestamp = new Date().toLocaleString()
        //console.log(timestamp);
        //timestamp = timestamp.replace('/', '_').replace(',', '_').replace(':', '_').replace(' ', '_');
        //console.log(timestamp);
        //var save_path = $scope.results_file_path + "_" + timestamp;
        var save_path = $scope.results_file_path;

        fs.writeFile(save_path, xmlText, function (err) {
          if (err) {
            return console.log(err);
          }
          window.alert("The EDAPT XML report was saved to " + save_path);
          console.log("The EDAPT XML report was saved to " + save_path);
        });
      }

    });

  // returns a list of the user-entered measure names for
  // a given design alternative.  Does not include
  function measureNames(alternative, measureCounts, numAlts) {
    var names = [];

    _(alternative.steps).forEach(function (step) {

      // skip measures that were set to "none,"
      // (which sets __SKIP__ argument to true)
      if (step.arguments.__SKIP__){
        console.log("Not including " + step.name + " because it was skipped.");
        return;
      }

      // skip reporting measures
      if (step.measure_type == 'ReportingMeasure') {
        console.log("Not including " + step.name + " because it is a reporting Measure.");
        return;
      }

      // skip always-run measures
      if (measureCounts[step.namePlusArgs] == numAlts) {
        console.log("Not including " + step.name + " because it is an always-run Measure.");
        return;
      }

      if (step.name) {
        names.push(step.name);
      }

    });

    return names;

  }

  // set $scope.results element in the controller above from PAT data
  function setData(data, reportDir) {
    var controllerElement = document.querySelector('div[ng-controller="MyAppCtrl"]');
    var $scope = angular.element(controllerElement).scope();
    $scope.$apply(function () {
      $scope.results = JSON.parse(data);
      $scope.reportDir = reportDir;
      $scope.setupAfterResultsAvailable();
    });
  }

</script>

</body>
</html>
